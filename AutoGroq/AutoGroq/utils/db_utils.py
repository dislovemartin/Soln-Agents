# db_utils.py

import datetime
import json
import sqlite3
import streamlit as st
import traceback
import uuid

from configs.config import FRAMEWORK_DB_PATH

from utils.text_utils import normalize_config
from utils.workflow_utils import get_workflow_from_agents


def export_to_autogen():
    db_path = FRAMEWORK_DB_PATH
    print(f"Database path: {db_path}")
    if db_path:
        export_data(db_path)
    else:
        st.warning("Please provide a valid database path in config.py.")


def export_data(db_path):
    print(f"Exporting data to: {db_path}")

    if db_path:
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            print("Connected to the database successfully.")

            agents = st.session_state.agents
            print(f"Number of agents: {len(agents)}")

            for index, agent in enumerate(agents):
                try:
                    print(f"Processing agent {index + 1}: {agent.name}")
                    
                    current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    
                    # Normalize the config
                    normalized_config = normalize_config(agent.to_dict(), agent.name)
                    
                    agent_data = (
                        None,  # id (AUTO INCREMENT)
                        current_time,  # created_at
                        current_time,  # updated_at
                        'guestuser@gmail.com',  # user_id
                        '0.0.1',  # version
                        'assistant',  # type
                        json.dumps(normalized_config),  # config (JSON)
                        normalized_config['system_message']  # task_instruction
                    )
                    
                    print(f"Inserting agent data: {agent_data}")
                    
                    cursor.execute("""
                        INSERT INTO agent (id, created_at, updated_at, user_id, version, type, config, task_instruction) 
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                    """, agent_data)
                    
                    print(f"Inserted agent: {agent.name}")

                except Exception as e:
                    print(f"Error processing agent {index + 1}: {str(e)}")
                    print(f"Agent data: {agent.__dict__}")
                    traceback.print_exc()

            # Handle skills/tools
            for tool in st.session_state.tool_models:
                try:
                    current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    skill_data = (
                        None,  # id (AUTO INCREMENT)
                        current_time,  # created_at
                        current_time,  # updated_at
                        'guestuser@gmail.com',  # user_id
                        '0.0.1',  # version
                        tool.name,
                        tool.content,
                        tool.description,
                        json.dumps(tool.secrets) if hasattr(tool, 'secrets') else '{}',
                        json.dumps(tool.libraries) if hasattr(tool, 'libraries') else '[]'
                    )
                    cursor.execute("""
                        INSERT INTO skill (id, created_at, updated_at, user_id, version, name, content, description, secrets, libraries)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """, skill_data)
                    print(f"Inserted skill: {tool.name}")
                except Exception as e:
                    print(f"Error inserting skill {tool.name}: {str(e)}")
                    traceback.print_exc()

            # Handle the workflow
            try:
                workflow_data, _ = get_workflow_from_agents(agents)
                current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                workflow_insert_data = (
                    None,  # id (AUTO INCREMENT)
                    current_time,  # created_at
                    current_time,  # updated_at
                    'guestuser@gmail.com',  # user_id
                    '0.0.1',  # version
                    workflow_data.get('name', 'AutoGroq Workflow'),
                    workflow_data.get('description', 'Workflow auto-generated by AutoGroq.'),
                    workflow_data.get('type', 'autonomous'),  # Default to 'autonomous' if not specified
                    workflow_data.get('summary_method', 'last')[:4],  # VARCHAR(4)
                    json.dumps(workflow_data.get('sample_tasks', []))
                )
                cursor.execute("""
                    INSERT INTO workflow (id, created_at, updated_at, user_id, version, name, description, type, summary_method, sample_tasks)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, workflow_insert_data)
                print("Inserted workflow data.")
            except Exception as e:
                print(f"Error inserting workflow: {str(e)}")
                traceback.print_exc()

            conn.commit()
            print("Changes committed to the database.")

            conn.close()
            print("Database connection closed.")

            st.success("Data exported to Autogen successfully!")
        except sqlite3.Error as e:
            st.error(f"Error exporting data to Autogen: {str(e)}")
            print(f"Error exporting data to Autogen: {str(e)}")
            traceback.print_exc()


def get_table_info(table_name):
    conn = sqlite3.connect(FRAMEWORK_DB_PATH)
    cursor = conn.cursor()
    cursor.execute(f"PRAGMA table_info({table_name})")
    columns = cursor.fetchall()
    conn.close()
    return columns


def insert_or_get_skill(cursor, tool):
    tool_name = tool.name if hasattr(tool, 'name') else tool.get('name', '')
    cursor.execute("SELECT id FROM skill WHERE name = ?", (tool_name,))
    result = cursor.fetchone()
    if result:
        return result[0]
    else:
        print(f"Inserting new skill: {tool}")
        
        skill_data = (
            None,  # id is INTEGER PRIMARY KEY, let SQLite auto-increment
            datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),  # created_at
            datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),  # updated_at
            'default',  # user_id
            '0.0.1',  # version
            str(tool_name),
            str(tool.content if hasattr(tool, 'content') else tool.get('content', '')),
            str(tool.description if hasattr(tool, 'description') else tool.get('description', '')),
            json.dumps(tool.secrets if hasattr(tool, 'secrets') else tool.get('secrets', {})),
            json.dumps(tool.libraries if hasattr(tool, 'libraries') else tool.get('libraries', []))
        )
        
        print(f"Skill data to be inserted: {skill_data}")
        
        try:
            cursor.execute("""
                INSERT INTO skill (id, created_at, updated_at, user_id, version, name, content, description, secrets, libraries) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, skill_data)
            return cursor.lastrowid
        except sqlite3.Error as e:
            print(f"SQLite error: {e}")
            print("Data types:")
            for i, item in enumerate(skill_data):
                print(f"  {i}: {type(item)}")
            raise
    

def insert_or_get_model(cursor, model_config):
    cursor.execute("SELECT id FROM model WHERE model = ?", (model_config['model'],))
    result = cursor.fetchone()
    if result:
        return result[0]
    else:
        model_data = (
            str(uuid.uuid4()),  # id
            datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),  # created_at
            datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),  # updated_at
            'guestuser@gmail.com',  # user_id
            '0.0.1',  # version
            model_config['model'],
            model_config.get('api_key'),
            model_config.get('base_url'),
            model_config.get('api_type', '')[:6],  # VARCHAR(6)
            model_config.get('api_version'),
            model_config.get('description', '')
        )
        cursor.execute("""
            INSERT INTO model (id, created_at, updated_at, user_id, version, model, api_key, base_url, api_type, api_version, description) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, model_data)
        return cursor.lastrowid
    

def insert_workflow(cursor, workflow_data):
    workflow_insert_data = (
        None,  # id is INTEGER PRIMARY KEY, let SQLite auto-increment
        datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),  # created_at
        datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),  # updated_at
        'guestuser@gmail.com',  # user_id (matching existing entries)
        '0.0.1',  # version
        workflow_data.get('name', 'AutoGroq Workflow'),
        workflow_data.get('description', 'Workflow auto-generated by AutoGroq.'),
        workflow_data.get('type', 'groupchat')[:10],  # VARCHAR(10)
        workflow_data.get('summary_method', 'last')[:4],  # VARCHAR(4)
        json.dumps(workflow_data.get('sample_tasks', []))
    )
    print(f"Inserting workflow data: {workflow_insert_data}")
    try:
        cursor.execute("""
            INSERT INTO workflow (id, created_at, updated_at, user_id, version, name, description, type, summary_method, sample_tasks) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, workflow_insert_data)
        return cursor.lastrowid
    except sqlite3.Error as e:
        print(f"SQLite error: {e}")
        print("Data types:")
        for i, item in enumerate(workflow_insert_data):
            print(f"  {i}: {type(item)}")
        raise


def sql_to_db(sql: str, params: tuple = None):
    try:
        conn = sqlite3.connect(FRAMEWORK_DB_PATH)
        cursor = conn.cursor()
        print("Connected to the database successfully.")
        if params:
            cursor.execute(sql, params)
        else:
            cursor.execute(sql)
        conn.commit()
        print("SQL executed successfully.")
    except sqlite3.Error as e:
        print(f"Error executing SQL: {str(e)}")
        print(f"SQL: {sql}")
        print(f"Params: {params}")
        raise
    finally:
        if conn:
            conn.close()
            print("Database connection closed.")
            

#FUTURE functions for exporting to new Autogen Studio schema:

# def create_or_update_agent(agent: dict, db_path: str):
#     with sqlite3.connect(db_path) as conn:
#         cursor = conn.cursor()
#         cursor.execute("""
#             INSERT OR REPLACE INTO Agent (id, skills, created_at, updated_at, user_id, workflows, type, config, models)
#             VALUES (:id, :skills, :created_at, :updated_at, :user_id, :workflows, :type, :config, :models)
#         """, agent)
#         conn.commit()

# def create_or_update_skill(skill: dict, db_path: str):
#     with sqlite3.connect(db_path) as conn:
#         cursor = conn.cursor()
#         cursor.execute("""
#             INSERT OR REPLACE INTO Skill (id, created_at, updated_at, user_id, name, content, description, secrets, libraries)
#             VALUES (:id, :created_at, :updated_at, :user_id, :name, :content, :description, :secrets, :libraries)
#         """, skill)
#         conn.commit()

# def create_or_update_workflow(workflow: dict, db_path: str):
#     with sqlite3.connect(db_path) as conn:
#         cursor = conn.cursor()
#         cursor.execute("""
#             INSERT OR REPLACE INTO Workflow (id, agents, created_at, updated_at, user_id, name, description, type, summary_method)
#             VALUES (:id, :agents, :created_at, :updated_at, :user_id, :name, :description, :type, :summary_method)
#         """, workflow)
#         conn.commit()

# def get_agent_by_id(agent_id: int, db_path: str) -> Optional[dict]:
#     with sqlite3.connect(db_path) as conn:
#         cursor = conn.cursor()
#         cursor.execute("SELECT * FROM Agent WHERE id = ?", (agent_id,))
#         row = cursor.fetchone()
#         if row:
#             columns = [column[0] for column in cursor.description]
#             return dict(zip(columns, row))
#     return None

# def get_skill_by_id(skill_id: int, db_path: str) -> Optional[dict]:
#     with sqlite3.connect(db_path) as conn:
#         cursor = conn.cursor()
#         cursor.execute("SELECT * FROM Skill WHERE id = ?", (skill_id,))
#         row = cursor.fetchone()
#         if row:
#             columns = [column[0] for column in cursor.description]
#             return dict(zip(columns, row))
#     return None

# def get_workflow_by_id(workflow_id: int, db_path: str) -> Optional[dict]:
#     with sqlite3.connect(db_path) as conn:
#         cursor = conn.cursor()
#         cursor.execute("SELECT * FROM Workflow WHERE id = ?", (workflow_id,))
#         row = cursor.fetchone()
#         if row:
#             columns = [column[0] for column in cursor.description]
#             return dict(zip(columns, row))
#     return None
